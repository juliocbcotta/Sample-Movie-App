package com.android.sample.list.abstraction.presentation

import com.android.sample.list.abstraction.MovieDetail
import com.android.sample.list.abstraction.presentation.MovieCardState.Initial
import com.android.sample.list.abstraction.presentation.MovieCardState.Loading
import com.android.sample.list.abstraction.presentation.MovieCardState.Success

interface MovieCardState {

    interface Initial : MovieCardState

    interface Loading : MovieCardState

    interface Success : MovieCardState {
        val result: MovieDetail
    }

    interface Error : MovieCardState
}

// Why do we need this? Because we can't have sealed interfaces declaration in one module
// and possible implementations in another modules. For instance, having Parcelables versions of this interface
// here would be a leaking into the abstraction.
// However this method could be generated by some compiler plugin
inline fun MovieCardState.which(
    onInitial: (initial: Initial) -> Unit,
    onLoading: (loading: Loading) -> Unit,
    onSuccess: (success: Success) -> Unit,
    onError: (error: Error) -> Unit
) {
    when (this) {
        is Initial -> onInitial(this)
        is Loading -> onLoading(this)
        is Success -> onSuccess(this)
        is Error -> onError(this)
    }
}

interface MovieCardEvent {
    interface RequestToReload : MovieCardEvent
}
